// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function insert(m, k, v) {
  return {
          hd: [
            k,
            v
          ],
          tl: m
        };
}

function lookup(m, k) {
  var v = Belt_List.getAssoc(m, k, Caml_obj.caml_equal);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  } else {
    return Pervasives.failwith("not found");
  }
}

function keys(m) {
  return Belt_List.sort(Belt_List.map(m, (function (prim) {
                    return prim[0];
                  })), Caml_obj.caml_compare);
}

function bindings(m) {
  return Belt_List.map(keys(m), (function (k) {
                return [
                        k,
                        lookup(m, k)
                      ];
              }));
}

var AssocListMap = {
  empty: /* [] */0,
  insert: insert,
  lookup: lookup,
  bindings: bindings
};

var m = insert(insert(/* [] */0, "e", 2.718), "pi", 3.14);

var m$p = insert(m, "phi", 1.618);

var b = bindings(m);

var b$p = bindings(m$p);

console.log(b, b$p);

function insert$1(m, k, v) {
  return {
          hd: [
            k,
            v
          ],
          tl: Belt_List.removeAssoc(m, k, Caml_obj.caml_equal)
        };
}

function lookup$1(m, k) {
  var v = Belt_List.getAssoc(m, k, Caml_obj.caml_equal);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  } else {
    return Pervasives.failwith("not found");
  }
}

function keys$1(m) {
  return Belt_List.sort(Belt_List.map(m, (function (prim) {
                    return prim[0];
                  })), Caml_obj.caml_compare);
}

function bindings$1(m) {
  return Belt_List.map(keys$1(m), (function (k) {
                return [
                        k,
                        lookup$1(m, k)
                      ];
              }));
}

var UniqAssocListMap = {
  empty: /* [] */0,
  insert: insert$1,
  lookup: lookup$1,
  bindings: bindings$1
};

exports.AssocListMap = AssocListMap;
exports.m = m;
exports.m$p = m$p;
exports.b = b;
exports.b$p = b$p;
exports.UniqAssocListMap = UniqAssocListMap;
/* m Not a pure module */
